<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/mixins/gesture-event-listeners.html">

<link rel="import" href="shared-styles.html">
<link rel="import" href="player-display.html">
<link rel="import" href="target-display.html">
<link rel="import" href="effect-display.html">
<link rel="import" href="options-menu.html">

<dom-module id="neuro-app">
  <template>
    <style include="shared-styles">
      :host {
        display: block;
        background-color: #000;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }
      #toolbar {
        height: 48px;
        background-color: #666;
        color: #fff;
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
      }
      #toolbar[connected] {
        height: 0;
      }
      .logo {
        height: 36px;
        width: 36px;
        margin-left: 12px;
      }
      .control {
        margin-left: 24px;
      }

      .control label {
        margin-right: 8px;
      }
      .connect {
        margin: 0 24px;
      }
      #toolbar[connected] .connect {
        position: fixed;
        right: 40px;
        top: 8px;
      }
      .options {
        margin-right: 24px;
        cursor: pointer;
        font-size: 24px;
        text-shadow: 0 0 2px #000;
      }
      #toolbar[connected] .options {
        position: fixed;
        right: 0px;
        top: 10px;
      }
      #output {
        flex: 1;
        font-family: 'Roboto Mono', monospace;
        font-size: 14px;
        white-space: pre-wrap;
        background-color: #000;
        color: #e0e0e0;
        padding: 8px;
        overflow-y: auto;
        border-left: 1px solid #555;
        border-right: 1px solid #555;
      }
      .output-message.error {
        display: block;
        border: 1px solid #f33;
        background-color: #faa;
        padding: 8px;
        color: #fff;
      }
      .output-message.info {
        display: block;
        border: 1px solid #33f;
        background-color: #aaf;
        color: #fff;
        padding: 8px;
      }
      .output-message a {
        color: var(--ranvier-green);
      }
      #input {
        display: block;
        font-family: 'Roboto Mono', monospace;
        font-size: 16px;
        height: 32px;
      }
      #targets {
        position: absolute;
        top: 48px;
        width: 100%;
        pointer-events: none;
      }
      #effects {
        position: absolute;
        top: 64px;
        right: 24px;
      }
      #effects[hidden] {
        display: none !important;
      }
      #optionsMenu {
        position: absolute;
        height: 200px;
        width: 384px;
        top: calc(50% - 100px);
        left: calc(50% - 150px);
      }
      #optionsMenu[hidden] {
        display: none !important;
      }
    </style>
    <div id="toolbar" connected$="[[_isConnected]]">
      <img class="logo" src="./assets/logo.png">

      <div class="control">
        <label for="hostname">Hostname</label>
        <input id="hostname" value="{{hostname::input}}" tabindex="0">
      </div>

      <div class="control">
        <label for="port">Port</label>
        <input id="port" value="{{port::input}}">
      </div>

      <button class="ranvier-btn connect" on-tap="connect" hidden$="[[_isConnected]]">Connect</button>
      <button class="ranvier-btn connect" on-tap="disconnect" hidden$="[[!_isConnected]]">Disconnect</button>
      <span class="options" title="Options" on-tap="_openOptions">&#x2699;</span>
    </div>

    <div id="output"></div>

    <input id="input" type="text" value="{{input::input}}" on-keydown="_checkEnter"></input>

    <player-display data="[[playerData]]" hidden$="[[!playerData]]"></player-display>

    <target-display id="targets" targets="[[playerData.targets]]" hidden$="[[!playerData]]"></target-display>

    <effect-display
      id="effects"
      hidden$="[[_effectsVisible(playerData, options.showEffects)]]"
      effects="[[playerData.effects]]"
      on-show-effects="_effectsCommand"
    ></effect-display>

    <options-menu
      id="optionsMenu"
      options="{{options}}"
      hidden$="[[!_optionsOpen]]"
      on-save="_optionsSaved"
      on-close="_closeOptions"
    ></options-menu>
  </template>

  <script>
    /**
     * @customElement
     * @polymer
     */
    class NeuroApp extends Polymer.GestureEventListeners(Polymer.Element) {
      static get is() { return 'neuro-app'; }
      static get properties() {
        return {
          hostname: {
            type: String,
            value: 'localhost'
          },

          port: {
            type: Number,
            value: 4000,
          },

          input: {
            type: String,
            value: ''
          },

          playerData: {
            type: Object,
            value: null,
          },

          options: {
            type: Object,
            notify: true,
            value: function () {
              return {
                fontSize: 14,
                showEffects: true,
                selectLastCommand: false,
              };
            },
          },

          _optionsOpen: {
            type: Boolean,
            value: false,
          },

          _isConnected: {
            type: Boolean,
            value: false,
          },
        };
      }

      ready() {
        super.ready();
        this.ansi_up = new AnsiUp;
        this._history = [];
        this._historyIndex = 0;
        if (require) {
          var Store = require('electron-store');
          this.store = new Store;
          this.options = this.store.get('options', {
            fontSize: 14,
            showEffects: true,
            selectLastCommand: false,
          });
        }
      }

      connect() {
        if (!this.hostname || !this.port) {
          return alert('Invalid hostname or port');
        }

        this.websocket = new WebSocket(`ws://${this.hostname}:${this.port}`);
        this.websocket.onopen = this._wsOnOpen.bind(this);
        this.websocket.onclose = this._wsOnClose.bind(this);
        this.websocket.onmessage = this._wsOnMessage.bind(this);
        this.websocket.onerror = this._wsOnError.bind(this);

        this.$.input.focus();
      }

      disconnect() {
        this.websocket.close();
      }

      writeOutput(message, elClass = '', raw = false) {
        var span = document.createElement('span');
        message = raw ? message : this.ansi_up.ansi_to_html(message);
        // find links
        message = message.replace(
          /[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/g,
          '<a href="http://$&" target="_blank" tabindex="-1">$&</a>'
        );
        span.innerHTML = message;

        span.classList.add('output-message');
        if (elClass) {
          span.classList.add(elClass);
        }

        this.$.output.appendChild(span);
        this.$.output.scrollTop = this.$.output.scrollHeight;
      }

      _wsOnMessage(e) {
        var data = JSON.parse(e.data);
        if (data.type === 'message') {
          this.writeOutput(data.message);
        } else if (data.type === 'data') {
          this.playerData = data.data;
        }
      }

      _wsOnOpen(e) {
        this._isConnected = true;
        this.writeOutput('Connected', 'info', true);
      }

      _wsOnClose(e) {
        this.writeOutput('Connection Closed', 'info', true);
        this.playerData = null;
        this._isConnected = false;
      }

      _wsOnError(e) {
        console.log(e);
        this.writeOutput('Websocket Error', 'error', true);
        this._isConnected = false;
      }

      _checkEnter(e) {
        if (e.key === 'Enter') {
          const message = this.input.trim();
          if (!message.length) {
            return;
          }

          if (
            require &&
            (message === 'quit' || message === 'exit') &&
            (!this.websocket || this.websocket.readyState === 3)
          ) {
            require('electron').remote.getCurrentWindow().close();
          }

          this.websocket.send(message);
          this._history.push(message);
          if (this.options.selectLastCommand) {
            this.$.input.select();
          } else {
            this.input = '';
          }
          this._historyIndex = this._history.length;
          return;
        }

        if (e.key === 'ArrowUp') {
          if (this._history[this._historyIndex - 1]) {
            this.$.input.value = this._history[--this._historyIndex];
          }
        }

        if (e.key === 'ArrowDown') {
          if (this._history[this._historyIndex + 1]) {
            this.$.input.value = this._history[++this._historyIndex];
          } else {
            this._historyIndex = this._history.length;
            this.$.input.value = '';
          }
        }
      }

      _effectsVisible() {
        return !this.options || !this.options.showEffects || !this.playerData;
      }

      _effectsCommand() {
        if (!this.websocket || this.websocket.readyState !== 1) {
          return;
        }

        this.websocket.send('effects');
      }

      _openOptions() {
        this._optionsOpen = true;
      }

      _closeOptions() {
        this._optionsOpen = false;
      }

      _optionsSaved() {
        this._optionsOpen = false;
        var fontSize = parseInt(this.options.fontSize, 10);
        this.$.output.style.fontSize = (isNaN(fontSize) ? 14 : fontSize) + 'px';

        if (this.store) {
          this.store.set('options', this.options);
        }
      }
    }

    window.customElements.define(NeuroApp.is, NeuroApp);
  </script>
</dom-module>
